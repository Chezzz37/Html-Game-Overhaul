<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Advanced 8 Worlds Platformer</title>
<style>
  /* Base styles */
  body { margin: 0; overflow: hidden; background: #111; font-family: Arial, sans-serif; color: white;}
  canvas { background: #222; display: block; margin: auto; }
  #ui {
    position: absolute; top: 10px; left: 10px; color: white; font-family: Arial;
    user-select: none;
  }
  #startScreen, #optionsScreen {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: black; display: flex; align-items: center; justify-content: center;
    flex-direction: column; color: white; font-family: Arial;
  }
  #optionsScreen { display: none; }
  button { padding: 15px 40px; font-size: 22px; margin: 10px; cursor: pointer; }
  label { margin: 10px 0; font-size: 18px;}
  input[type=range] { width: 200px;}
  select { font-size: 16px; padding: 5px; margin-left: 10px;}
  #pauseOverlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.75); display: none;
    align-items: center; justify-content: center; font-size: 36px;
  }
</style>
</head>
<body>
<div id="startScreen">
  <h1>8 Worlds Platformer</h1>
  <button id="startBtn">Start Game</button>
  <button id="optionsBtn">Options</button>
</div>

<div id="optionsScreen">
  <h2>Options</h2>
  <label>Volume: <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="0.5"></label>

  <label for="graphicsQuality">Graphics Quality:
    <select id="graphicsQuality">
      <option value="high">High</option>
      <option value="medium">Medium</option>
      <option value="low">Low</option>
    </select>
  </label>

  <label><input type="checkbox" id="toggleSound" checked> Sound Effects</label>
  <label><input type="checkbox" id="toggleMusic" checked> Background Music</label>
  
  <button id="backBtn">Back</button>
</div>

<div id="pauseOverlay">Paused</div>

<div id="ui">World: <span id="world">1</span> | Level: <span id="level">1</span> | Lives: <span id="lives">3</span> | Score: <span id="score">0</span></div>

<canvas id="game" width="900" height="500"></canvas>

<script>
(() => {
  // == Variables and Constants ==
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const startScreen = document.getElementById('startScreen');
  const optionsScreen = document.getElementById('optionsScreen');
  const pauseOverlay = document.getElementById('pauseOverlay');

  const volumeSlider = document.getElementById('volumeSlider');
  const toggleSoundCheckbox = document.getElementById('toggleSound');
  const toggleMusicCheckbox = document.getElementById('toggleMusic');
  const graphicsQualitySelect = document.getElementById('graphicsQuality');

  const worldSpan = document.getElementById('world');
  const levelSpan = document.getElementById('level');
  const livesSpan = document.getElementById('lives');
  const scoreSpan = document.getElementById('score');

  const startBtn = document.getElementById('startBtn');
  const optionsBtn = document.getElementById('optionsBtn');
  const backBtn = document.getElementById('backBtn');

  // Sounds
  const jumpSound = new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg');
  const coinSound = new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');
  const hitSound = new Audio('https://actions.google.com/sounds/v1/cartoon/metal_twang.ogg');

  // Background Music (looped)
  const bgMusic = new Audio('https://cdn.pixabay.com/download/audio/2022/03/26/audio_47fc06e8c9.mp3?filename=chiptune-arcade-loop-13167.mp3');
  bgMusic.loop = true;
  bgMusic.volume = 0.3;

  // Initial States
  let gameStarted = false;
  let gamePaused = false;
  let keys = {};
  let gamepadIndex = null;

  // Physics and Player
  const gravity = 0.6;
  let score = 0;
  let lives = 3;

  // Settings persistence
  let graphicsQuality = localStorage.getItem('graphicsQuality') || 'high';
  graphicsQualitySelect.value = graphicsQuality;

  let soundEnabled = localStorage.getItem('soundEnabled') !== 'false'; // default true
  toggleSoundCheckbox.checked = soundEnabled;

  let musicEnabled = localStorage.getItem('musicEnabled') !== 'false'; // default true
  toggleMusicCheckbox.checked = musicEnabled;

  // Max particles and shadows for graphics quality
  let maxParticles = 40;
  let enableShadows = true;

  // Player Object (extended with acceleration)
  let player = {
    x: 50,
    y: 300,
    w: 30,
    h: 40,
    vx: 0,
    vy: 0,
    onGround: false,
    maxSpeed: 5,
    accel: 0.5,
    friction: 0.7,
  };

  // UI Update Function
  function updateUI(){
    worldSpan.textContent = currentWorld + 1;
    levelSpan.textContent = currentLevel + 1;
    livesSpan.textContent = lives;
    scoreSpan.textContent = score;
  }

  // Game Data Generators
  function generatePlatforms(){
    let arr = [];
    for(let i = 0; i < 6; i++) arr.push({x: Math.random() * 800, y: Math.random() * 350 + 50, w: 120, h: 20});
    arr.push({x:0,y:470,w:900,h:30});
    return arr;
  }
  function generateMovingPlatforms(){
    return [
      {x: 200, y: 300, w: 100, h: 20, dir: 1, range: [100,700]},
      {x: 450, y: 250, w: 100, h: 20, dir: -1, range: [100,700]}
    ];
  }
  function generateHazards(){
    let arr = [];
    for(let i = 0; i < 3; i++) arr.push({x: Math.random() * 800, y: 450, w: 40, h: 20});
    return arr;
  }
  function generateCoins(){
    let arr = [];
    for(let i = 0; i < 10; i++) arr.push({x: Math.random() * 800, y: Math.random() * 350 + 50, collected: false});
    return arr;
  }
  function generateEnemies(){
    let arr = [];
    for(let i = 0; i < 3; i++) arr.push({x: Math.random() * 700 + 100, y: 430, w: 30, h: 30, alive: true, dir: 1, patrolRange: [100, 800]});
    return arr;
  }

  // Worlds and levels
  let worlds = [];
  for(let w=0; w<8; w++){
    let levels = [];
    for(let l=0; l<9; l++){
      levels.push({
        platforms: generatePlatforms(),
        movingPlatforms: generateMovingPlatforms(),
        hazards: generateHazards(),
        coins: generateCoins(),
        enemies: generateEnemies()
      });
    }
    worlds.push(levels);
  }

  let currentWorld = 0;
  let currentLevel = 0;

  // --- Input Handling ---
  addEventListener('keydown', e=>{
    if(e.repeat) return; // prevent repeat for some actions
    keys[e.key.toLowerCase()] = true;

    if(e.key === 'Escape' && gameStarted){
      togglePause();
    }
  });
  addEventListener('keyup', e=>{
    keys[e.key.toLowerCase()] = false;
  });

  window.addEventListener("gamepadconnected", (e)=>{ gamepadIndex = e.gamepad.index; });
  window.addEventListener("gamepaddisconnected", ()=>{ gamepadIndex = null; });

  // Check collision helper
  function collide(a, b) {
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

  // Game Logic Functions
  function loseLife() {
    if(soundEnabled) hitSound.play();
    lives--;
    resetPlayer();
    if(lives <= 0) {
      alert('Game Over!');
      resetGame();
    }
  }

  function resetPlayer(){
    player.x = 50;
    player.y = 300;
    player.vx = 0;
    player.vy = 0;
  }

  function resetGame() {
    lives = 3;
    score = 0;
    currentWorld = 0;
    currentLevel = 0;
    resetPlayer();
  }

  function nextLevel(){
    currentLevel++;
    if(currentLevel >= worlds[currentWorld].length){
      currentWorld++;
      currentLevel = 0;
      if(currentWorld >= worlds.length){
        alert("Congratulations! You completed all worlds!");
        resetGame();
        gameStarted = false;
        startScreen.style.display = 'flex';
      }
    }
    resetPlayer();
  }

  // Smooth horizontal movement with accel & friction
  function handleMovement(moveLeft, moveRight) {
    if(moveLeft && !moveRight) {
      player.vx -= player.accel;
    } else if(moveRight && !moveLeft) {
      player.vx += player.accel;
    } else {
      // apply friction
      player.vx *= player.friction;
      if(Math.abs(player.vx) < 0.1) player.vx = 0;
    }
    // clamp max speed
    if(player.vx > player.maxSpeed) player.vx = player.maxSpeed;
    else if(player.vx < -player.maxSpeed) player.vx = -player.maxSpeed;
  }

  // Gamepad buttons mapped for common controllers
  function getGamepadInput() {
    if(gamepadIndex === null) return {moveLeft: false, moveRight: false, jump: false, pause: false};

    const gp = navigator.getGamepads()[gamepadIndex];
    if(!gp) return {moveLeft: false, moveRight: false, jump: false, pause: false};

    return {
      moveLeft: gp.axes[0] < -0.3,
      moveRight: gp.axes[0] > 0.3,
      jump: gp.buttons[0].pressed || gp.buttons[1].pressed,
      pause: gp.buttons[9].pressed  // Start button, often button 9
    };
  }

  // Main update function
  function update() {
    if(!gameStarted || gamePaused) return;

    // Get controls
    let moveLeft = keys['arrowleft'] || keys['a'];
    let moveRight = keys['arrowright'] || keys['d'];
    let jump = keys[' '] || keys['w'] || keys['arrowup'];

    const gpInput = getGamepadInput();
    moveLeft = moveLeft || gpInput.moveLeft;
    moveRight = moveRight || gpInput.moveRight;
    jump = jump || gpInput.jump;
    if(gpInput.pause) togglePause();

    handleMovement(moveLeft, moveRight);

    // Jump handling
    if(jump && player.onGround) {
      if(soundEnabled) jumpSound.play();
      player.vy = -12;
      player.onGround = false;
    }

    player.vy += gravity;
    player.x += player.vx;
    player.y += player.vy;

    player.onGround = false;

    const lvl = worlds[currentWorld][currentLevel];

    // Platforms collision (static)
    lvl.platforms.forEach(p => {
      if (collide(player, p) && player.vy >= 0){
        player.y = p.y - player.h;
        player.vy = 0;
        player.onGround = true;
      }
    });

    // Moving platforms collision and movement
    lvl.movingPlatforms.forEach(p => {
      p.x += p.dir * 2;
      if(p.x < p.range[0] || p.x > p.range[1]) p.dir *= -1;
      if (collide(player, p) && player.vy >= 0){
        player.y = p.y - player.h;
        player.vy = 0;
        player.onGround = true;
        // Move player along with platform
        player.x += p.dir * 2;
      }
    });

    // Hazards collision
    lvl.hazards.forEach(h => {
      if(collide(player, h)) {
        loseLife();
      }
    });

    // Enemies movement and collision
    lvl.enemies.forEach(e => {
      if(!e.alive) return;
      e.x += e.dir * 1.5;
      if(e.x < e.patrolRange[0] || e.x > e.patrolRange[1]) e.dir *= -1;

      if(collide(player, e)) {
        if(player.vy > 0 && player.y < e.y) {
          e.alive = false;
          score += 100;
          player.vy = -8;
          if(soundEnabled) coinSound.play();
        } else {
          loseLife();
        }
      }
    });

    // Coins collection
    lvl.coins.forEach(c => {
      if(!c.collected && collide(player, {x: c.x, y: c.y, w:10, h:10})) {
        c.collected = true;
        score += 10;
        if(soundEnabled) coinSound.play();
      }
    });

    // Stay inside bounds horizontally
    if(player.x < 0) player.x = 0;
    else if(player.x + player.w > canvas.width) player.x = canvas.width - player.w;

    // If fall below screen
    if(player.y > canvas.height) {
      loseLife();
    }

    // Next level
    if(player.x > canvas.width - player.w) {
      nextLevel();
    }

    updateUI();
  }

  // Draw function with particle effects placeholder
  let particleList = [];

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if(!gameStarted) return;

    // Shadows if enabled
    if(enableShadows){
      ctx.shadowColor = 'rgba(0,0,0,0.7)';
      ctx.shadowBlur = 6;
    } else {
      ctx.shadowBlur = 0;
    }
    
    const lvl = worlds[currentWorld][currentLevel];

    // Draw platforms
    ctx.fillStyle = 'white';
    lvl.platforms.forEach(p => {
      ctx.fillRect(p.x, p.y, p.w, p.h);
    });

    // Draw moving platforms
    ctx.fillStyle = 'lightblue';
    lvl.movingPlatforms.forEach(p => {
      ctx.fillRect(p.x, p.y, p.w, p.h);
    });

    // Draw hazards
    ctx.fillStyle = 'red';
    lvl.hazards.forEach(h => {
      ctx.fillRect(h.x, h.y, h.w, h.h);
    });

    // Draw coins
    ctx.fillStyle = 'yellow';
    lvl.coins.forEach(c => {
      if(!c.collected) ctx.fillRect(c.x, c.y, 10, 10);
    });

    // Draw enemies
    ctx.fillStyle = 'orange';
    lvl.enemies.forEach(e => {
      if(e.alive)
        ctx.fillRect(e.x, e.y, e.w, e.h);
    });

    // Draw player
    ctx.fillStyle = 'cyan';
    ctx.fillRect(player.x, player.y, player.w, player.h);

    // Particle effects can be added here per graphics quality (Optional)
    // For example, draw some star particles on high quality
    if(graphicsQuality !== "low") {
      drawParticles();
    }
  }

  // Particle system for visual effects (e.g., occasional sparkles)
  function drawParticles() {
    if(particleList.length < maxParticles) {
      particleList.push({
        x: player.x + player.w/2 + (Math.random()-0.5)*40,
        y: player.y + player.h/2 + (Math.random()-0.5)*40,
        size: Math.random()*2 + 1,
        alpha: 1,
        vy: - (Math.random() * 1 + 0.5),
      });
    }
    for(let i=particleList.length-1; i>=0; i--) {
      let p = particleList[i];
      ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
      p.y += p.vy;
      p.alpha -= 0.02;
      if(p.alpha <= 0) particleList.splice(i,1);
    }
  }

  // Toggle Pause Functionality
  function togglePause() {
    if(!gameStarted) return;
    gamePaused = !gamePaused;
    pauseOverlay.style.display = gamePaused ? 'flex' : 'none';
    if(gamePaused){
      if(!bgMusic.paused) bgMusic.pause();
    } else {
      if(musicEnabled) bgMusic.play();
    }
  }

  // Graphics quality settings applied repeatedly for dynamic change
  function applyGraphicsQuality(){
    if(graphicsQuality === "low"){
        maxParticles = 5;
        enableShadows = false;
    }else if(graphicsQuality === "medium"){
        maxParticles = 15;
        enableShadows = false;
    }else{
        maxParticles = 40;
        enableShadows = true;
    }
    localStorage.setItem("graphicsQuality", graphicsQuality);
  }
  applyGraphicsQuality();

  // Volume and sound toggling
  function updateVolumes(){
    const vol = volumeSlider.value;
    jumpSound.volume = soundEnabled ? vol : 0;
    coinSound.volume = soundEnabled ? vol : 0;
    hitSound.volume = soundEnabled ? vol : 0;
    bgMusic.volume = musicEnabled ? vol * 0.6 : 0;
  }
  updateVolumes();

  // == Event Listeners for UI ==
  startBtn.onclick = () => {
    startScreen.style.display = 'none';
    optionsScreen.style.display = 'none';
    gameStarted = true;
    resetGame();
    resetPlayer();
    updateUI();
    if(musicEnabled) bgMusic.play();
  };
  optionsBtn.onclick = () => {
    startScreen.style.display = 'none';
    optionsScreen.style.display = 'flex';
  };
  backBtn.onclick = () => {
    optionsScreen.style.display = 'none';
    startScreen.style.display = 'flex';
  };
  volumeSlider.oninput = () => {
    updateVolumes();
  };
  toggleSoundCheckbox.onchange = () => {
    soundEnabled = toggleSoundCheckbox.checked;
    localStorage.setItem('soundEnabled', soundEnabled);
    updateVolumes();
  };
  toggleMusicCheckbox.onchange = () => {
    musicEnabled = toggleMusicCheckbox.checked;
    localStorage.setItem('musicEnabled', musicEnabled);
    updateVolumes();
    if(!musicEnabled) bgMusic.pause();
    else if(gameStarted && !gamePaused) bgMusic.play();
  };
  graphicsQualitySelect.onchange = () => {
    graphicsQuality = graphicsQualitySelect.value;
    applyGraphicsQuality();
  };

  // Accessibility: show controls info on start screen
  const controlsInfo = document.createElement('div');
  controlsInfo.style.position = 'absolute';
  controlsInfo.style.bottom = '20px';
  controlsInfo.style.left = '10px';
  controlsInfo.style.color = 'white';
  controlsInfo.style.fontSize = '14px';
  controlsInfo.style.userSelect = 'none';
  controlsInfo.innerHTML = `
    Controls: Arrow Keys/A-D to move, W/Space/Up to jump, Esc to pause
  `;
  document.body.appendChild(controlsInfo);

  // Fixed timestep for update loop for performance consistency
  let lastFrameTime = 0;
  const targetFPS = 60;
  const targetFrameDuration = 1000 / targetFPS;

  function gameLoop(timestamp=0) {
    if(!lastFrameTime) lastFrameTime = timestamp;
    const delta = timestamp - lastFrameTime;

    if(delta > targetFrameDuration){
      update();
      draw();
      lastFrameTime = timestamp;
    }
    requestAnimationFrame(gameLoop);
  }

  // Start the loop
  requestAnimationFrame(gameLoop);
})();
</script>

</body>
</html>
